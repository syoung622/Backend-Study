### 스프링이란?

스프링 프레임워크뿐만 아니라 db에 접근하도록 도와주는 스프링 데이터 등 다양한 스프링 기술이 존재하며 이러한 여러 기술들의 모음이라고 할 수 있음.

- 필수 기술
    - 스프링 프레임워크
    - 스프링 부트

- 그 밖의 기술
    - 스프링 데이터
    - 스프링 세션
    - 스프링 시큐리티
    - 스프링 Rest Docs
    - 스프링 배치
    - 스프링 클라우드


#### 스프링 프레임워크

스프링 DI 컨테이너, AOP, 이벤트 등의 핵심 기술과 함께 여러가지 기술들을 합쳐서 만든 프레임워크로 웹 기술, 데이터 접근 기술, 테스트, 언어 등이 함께 지원됨.

- 스프링 MVC, 스프링 WebFlux와 같은 웹 기술 지원
- 트랜잭션, JDBC, ORM, XML과 같은 데이터 접근 기술 지원
- 캐시, 이메일 등의 기술 통합 지원
- 스프링 기반 테스트(JUnit) 지원
- 코틀린, 그루비 언어 지원

#### 스프링 부트

스프링 프레임워크에선 Tomcat 웹 서버를 따로 구축, 외부 라이브러리의 버전을 스프링 버전에 맞게 지정해야 하는 등의 초기 설정을 위한 번거로운 작업들이 필요했음.
하지만 스프링 부트는 이를 편리하게 사용하도록 지원함.

- Tomcat과 같은 내장 서버 지원
- 손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 하나만 가져오면 관련 종속성 모두 가져옴.)
- 스프링과 외부 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성과 같은 프로덕션 준비 기능제공(모니터링 기능 제공)
- 관례에 의한 간결한 설정(xml을 통한 설정이 필요 없어짐. 추가적인 설정은 properties를 통해서 가능)


#### 스프링 핵심 개념

스프링은 자바 언어 기반의 프레임워크임.
따라서 스프링은 자바 언어의 가장 큰 특징인 <b>객체 지향 언어</b>의 특징을 잘 살려낸 프레임워크로 유연하고 확장성 있는 개발을 가능하게 함.



---

### 좋은 객체 지향 프로그래밍?

#### 객체 지향 프로그래밍

컴퓨터 프로그램을 <b>객체들의 모임</b>으로 간주하여 프로그램을 유연하고 변경에 용이하도록 함.


##### 유연하고 변경에 용이?

컴퓨터의 모니터, 키보드, 마우스 등의 부품을 갈아끼우는 것처럼 컴포넌트를 쉽게 변경할 수 있는 방법을 의미함.
이러한 방법을 객체 지향 프로그래밍의 핵심인 다형성이라 함.

#### 다형성

실세계에 비유하자면, <b>역할</b>과 <b>구현</b>으로 세상을 구분할 수 있음.
역할을 인터페이스, 구현을 인터페이스를 구현한 객체라고 생각하면 됨.

##### 예시) 운전자 - 자동차

![polymorphism](https://media.vlpt.us/images/lsj16632/post/ef286ebb-e5d2-4410-88fa-e70ba8d192e2/img1.png)


운전자 역할과 자동차 역할이 존재.
자동차 역할을 K3, 아반떼, 테슬라 모델3가 구현함.

###### 운전자가 자동차를 K3에서 아반떼로 바꾼다면?

운전자는 아반떼용 운전법을 다시 익혀야하는가?

자동차가 변경되면서 디자인 등의 속성은 달라질 수 있지만 엑셀 기능, 브레이크 기능 등 자동차의 역할은 변하지 않음.
따라서 자동차가 그 역할만 잘한다면 자동차의 종류와 상관없이 운전 면허를 가진 운전자는 운전이 가능함.

즉, 자동차의 역할만 잘 수행되면 얼마든지 새로운 자동차를 만들 수 있는 확장성을 제공할 수 있음. 운전자는 자동차의 역할만 알면 되고 구현한 자동차의 내부 구조는 알 필요가 없음. 따라서 내부 구조 변경에 매우 용이함.


##### 역할과 구현을 분리

역할과 구현을 분리하여 객체 지향의 장점인 유연성, 확장성을 편리하게 사용 가능.

- 위의 예시처럼 클라이언트는 역할만 알고 구현 대상의 내부 구조는 몰라도 됨. 따라서 내부 구조가 변경되어도 영향 없음.
- 구현 대상 자체를 변경해도 클라이언트에 영향 없음.


##### 자바언어의 역할과 구현 분리

- 다형성을 활용
    - 역할: 인터페이스
    - 구현: 인터페이스를 구현한 객체
    - 오버라이딩을 통해서 다형성 사용 가능

        - 오버라이딩된 메서드가 실행되며 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능

        ![java-polymorphism](https://media.vlpt.us/images/kai/post/907e98d9-c018-43b0-a863-4b9facf96198/image.png)

        
        - 위 그림에서 클라이언트인 MemberService는 MemberRepository를 의존함.(의존한다는 것은 해당 클래스를 알고 있다는 의미)

        - MemberRepository에서는 MemoryMemberRepository나 JdbcMemberRepository 기능을 할당할 수 있음.

        ``` java
        
        public class MemberService{
            // private MemberRepository memberRepository = new MemoryMemberRepository();
            private MemberRepository memberRepository = new JdbcMemberRepository();
        }
        ``` 

        

#### 다형성의 본질

- 다형성의 본질을 이해하기 위해서는 객체는 혼자가 아닌 클라이언트의 요청과 서버의 응답으로 이루어진 협력 관계라는 이해가 필요.
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있음.


#### 한계

- 인터페이스가 변하면 이를 구현하는 구현체뿐만 아니라 클라이언트, 서버 모두 변경해야함.
- 따라서 인터페이스를 설계할 때, 변화가 가장 없는 방식으로 안정적이게 설계하는 것이 매우 중요


#### 스프링과 객체 지향

객체 지향에서 다형성이 가장 중요하며 스프링은 이 다형성을 극대화해서 이용할 수 있게 해줌.

- 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원함.


---


### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

로버트 마틴이라는 사람이 좋은 객체 지향 설계에 대한 5가지 원칙을 정리한 것

- SRP: 단일 책임 원칙
- OCP: 개방 폐쇄 원칙
- LSP: 리스코프 치환 원칙
- ISP: 인터페이스 분리 원칙
- DIP: 의존관계 역전 원칙


#### SRP 단일 책임 원칙

<b>하나의 클래스는 하나의 책임만 가진다.</b>

하나의 책임을 가진다는 의미는 그만큼 변경이 적다는 것.(하나의 클래스의 하나의 지점만 변경했을 때 단일 책임 원칙을 잘 따랐다고 할 수 있음.)
책임의 범위를 적절하게 정하는 것이 중요.


#### OCP 개방 폐쇄 원칙

<b>소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.</b>

다형성을 이용해서 코드를 변경하지 않고 확장이 가능.


``` java
    public class MemberService{

        // private MemberRepository memberRepository = new MemoryMemberRepository();
        private MemberRepository memberRepository = new JdbcMemberRepository();

    }
```

하지만 위의 MemberService에서 MemberRepository를 MemoryMemberRepository에서 JdbcMemberRepository로 주석을 통해서 코드 변경하였음.

여기서 다형성을 이용했지만 OCP 원칙은 위반
그렇다면 다형성을 활용해서 OCP 원칙을 지킬 수 없는 것인가?

이를 해결하기 위해선 객체 생성, 관계 수립을 해주는 설정자가 필요, 이것이 스프링 컨테이너의 역할


#### LSP 리스코프 치환 원칙

<b>객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</b>

구현체는 인터페이스에서 정의한 규약을 모두 지켜야 한다.

ex) 위의 자동차 예시에서 자동차 인터페이스(자동차 역할)가 엑셀을 밟으면 전진하는 기능이 있다고 할 때, 자동차 구현체(아반떼, K3)는 전진 기능의 책임을 다해야 함. 만일 엑셀을 밟았는데 전진하지 않고 후진한다면 LSP 원칙에 위배된 것

단순히 컴파일 성공의 문제가 아니라 클라이언트는 구현체가 해당 인터페이스에 대한 책임을 다할 것이라고 생각하고 수행하는 것이기 때문에 이 원칙을 위반하면 안됨.


#### ISP 인터페이스 분리 원칙

<b>클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다</b>

범용 인터페이스 하나보다는 특정 목적을 가진 인터페이스 여러개를 생성하는 것이 나음.
인터페이스가 커지면 클라이언트는 사용하지 않는 기능을 갖게 되면서 불필요한 결합도를 가지게 됨.

ex) 자동차 인터페이스 또한 운전 인터페이스와 정비 인터페이스로 분리, 사용자 클라이언트도 운전자 클라이언트와 정비사 클라이언트로 분리
이렇게 분리하면 정비 인터페이스가 변해도 운전자 클라이언트에는 영향을 주지 않음.

``` java
// ISP 적용 전
public interface Car{

    void drive();
    void fix();

}


// ISP 적용 후
public interface Drive{

    void drive();

}

public interface Fix{

    void fix();

}
```  

위와 같이 운전, 정비에 대한 범용 자동차 인터페이스를 생성하는 것보다, 특정 기능만 담은 인터페이스를 여러개 생성하는 것이 좋음.

이러한 방식으로 인터페이스 클라이언트는 꼭 필요한 메서드들만 이용 가능함.


#### DIP 의존관계 역전 원칙

<b>프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.</b>

클라이언트는 구현체가 아닌 인터페이스에 의존해야한다는 의미


``` java
public class MemberService{

    // private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();

}
``` 

그런데 이전 예제 코드에서 보면 MemberService가 구현체를 직접 선택하면서 구현 클래스에도 의존하는 것을 확인할 수 있음. 
이는 DIP를 위반하는 것.


SOLID 원칙을 기준으로 객체 지향의 핵심적인 특징인 다형성을 적용하였을 때,

- 객체 변경 시, 클라이언트 코드 변경 -> OCP 원칙 위배
- 구현 클래스를 지정하면서 구현체에도 의존 -> DIP 원칙 위배

OCP, DIP 원칙은 지키지 못함. 이 원칙을 위한 뭔가가 더 필요함.


---

### 객체 지향 설계와 스프링


위에서 객체 지향의 다형성만으로는 SOLID 5가지 원칙 중에서 OCP, DIP가 위배된다고 하였는데 이를 해결해주는 것이 스프링임.

DI를 활용해서 OCP, DIP 위반 문제를 해결할 수 있음.


``` java
public class MemberService{

    // private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();

}
```

OCP, DIP를 위반한 위의 코드를 DI를 이용해서 해결할 수 있음.

``` java
public class MemberService{

    private MemberRepository memberRepository;

    //생성자
    public MemberService(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }

    //setter
    public void setMemberRepository(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }

}
```

생성자와 Setter를 통해 MemberRepository를 상속받아서 구현된 클래스의 인스턴스를 실행시점에 외부에서 주입하면 클라이언트인 MemberService는 직접 구현체를 선택하지 않아도 됨.

- MemberRepository 인터페이스에만 의존 -> DIP 위반 문제 해결
- 클라이언트에서 코드 수정 필요 없어짐 -> OCP 위반 문제 해결

인스턴스를 실행 시점에 외부에서 주입해주는 역할을 스프링의 DI 컨테이너가 함.



