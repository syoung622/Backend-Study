### 스프링

스프링 프레임워크, 스프링 데이터 등 다양한 스프링 기술들의 모음

- 필수 기술
    - 스프링 프레임워크 : DI, AOP, 웹 기술, 데이터 접근 기술 등
    - 스프링 부트 : 스프링 기술을 위한 웹 서버, 초기 설정 등을 지원

- 그 밖의 기술
    - 스프링 데이터
    - 스프링 세션
    - 스프링 시큐리티
    - 스프링 Rest Docs
    - 스프링 배치
    - 스프링 클라우드


#### 스프링 핵심 개념

자바 언어의 가장 큰 특징인 <b>객체 지향 언어</b>의 특징을 잘 살려낸 프레임워크로 유연하고 확장성 있는 개발 가능



---
### 객체 지향 프로그래밍

컴퓨터 프로그램을 <b>객체들의 모임</b>으로 간주하여 프로그램을 유연하고 변경에 용이하도록 함.
이를 <b>다형성</b>이라 함.

#### 다형성

실세계에 비유하자면, <b>역할</b>과 <b>구현</b>으로 세상을 구분할 수 있음.
역할을 인터페이스, 구현을 인터페이스를 구현한 객체라고 생각하면 됨.


<details>
<summary>운전자-자동차 예시</summary>

![polymorphism](https://media.vlpt.us/images/lsj16632/post/ef286ebb-e5d2-4410-88fa-e70ba8d192e2/img1.png)


운전자 역할과 자동차 역할이 존재.
자동차 역할을 K3, 아반떼, 테슬라 모델3가 구현함.

###### 운전자가 자동차를 K3에서 아반떼로 바꾼다면?

운전자는 아반떼용 운전법을 다시 익혀야하는가?

자동차가 변경되면서 디자인 등의 속성은 달라질 수 있지만 엑셀 기능, 브레이크 기능 등 자동차의 역할은 변하지 않음.
따라서 자동차가 그 역할만 잘한다면 자동차의 종류와 상관없이 운전 면허를 가진 운전자는 운전이 가능함.

즉, 자동차의 역할만 잘 수행되면 얼마든지 새로운 자동차를 만들 수 있는 확장성을 제공할 수 있음. 운전자는 자동차의 역할만 알면 되고 구현한 자동차의 내부 구조는 알 필요가 없음. 따라서 내부 구조 변경에 매우 용이함.



</details>


##### 자바언어의 역할과 구현 분리

- 다형성을 활용
    - 역할: 인터페이스
    - 구현: 인터페이스를 구현한 객체
    - 오버라이딩을 통해서 다형성 사용 가능

        - 오버라이딩된 메서드가 실행되며 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능

        ![java-polymorphism](https://media.vlpt.us/images/kai/post/907e98d9-c018-43b0-a863-4b9facf96198/image.png)

        

        ``` java
        
        public class MemberService{
            // private MemberRepository memberRepository = new MemoryMemberRepository();
            private MemberRepository memberRepository = new JdbcMemberRepository();
        }
        ``` 

        

#### 다형성의 본질

- 객체는 혼자가 아닌 클라이언트의 요청과 서버의 응답으로 이루어진 협력 관계
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있음.


#### 한계

- 인터페이스가 변하면 이를 구현하는 구현체뿐만 아니라 클라이언트, 서버 모두 변경해야함.
- 따라서 인터페이스를 설계할 때, 변화가 가장 없는 방식으로 안정적이게 설계해야함.


#### 스프링과 객체 지향

객체 지향에서 다형성이 가장 중요하며 스프링은 이 다형성을 극대화해서 이용할 수 있게 해줌.

- 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원함.


---


### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP 단일 책임 원칙
    - <b>하나의 클래스는 하나의 책임만 가진다.</b>
    - 하나의 책임을 가진다는 의미는 그만큼 변경이 적다는 것.



- OCP 개방 폐쇄 원칙
    - <b>소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.</b>
    - 다형성을 이용해서 코드를 변경하지 않고 확장이 가능.

- LSP 리스코프 치환 원칙
    - <b>객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</b>
    - 구현체는 인터페이스에서 정의한 규약을 모두 지켜야 한다.

- ISP 인터페이스 분리 원칙
    - <b>클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다</b>
    - 범용 인터페이스 하나보다는 특정 목적을 가진 인터페이스 여러개를 생성하는 것이 나음.
    - 인터페이스가 커지면 클라이언트는 사용하지 않는 기능을 갖게 되면서 불필요한 결합도를 가지게 됨.
        <details>
        <summary>자동차 예시</summary>

        - 자동차 인터페이스 또한 운전 인터페이스와 정비 인터페이스로 분리, 사용자 클라이언트도 운전자 클라이언트와 정비사 클라이언트로 분리
        - 이렇게 분리하면 정비 인터페이스가 변해도 운전자 클라이언트에는 영향을 주지 않음.

        ``` java

        // ISP 적용 전
        public interface Car{

            void drive();
            void fix();

        }


        // ISP 적용 후
        public interface Drive{

            void drive();

        }

        public interface Fix{

            void fix();

        }
        ```

        위와 같이 운전, 정비에 대한 범용 자동차 인터페이스를 생성하는 것보다, 특정 기능만 담은 인터페이스를 여러개 생성하는 것이 좋음.

        이러한 방식으로 인터페이스 클라이언트는 꼭 필요한 메서드들만 이용 가능함.
        </details>


- DIP 의존관계 역전 원칙
    - <b>프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.</b>
    - 클라이언트는 구현체가 아닌 인터페이스에 의존해야한다는 의미


---

객체 지향의 다형성으로 SOLID 5가지 원칙을 다 지키지 못함.

``` java
public class MemberService{

    // private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();

}
``` 

- 객체 변경 시, 클라이언트 코드 변경 -> OCP 원칙 위배
- 구현 클래스를 지정하면서 구현체에도 의존 -> DIP 원칙 위배


DI를 활용해서 OCP, DIP 위반 문제를 해결할 수 있음.


``` java
public class MemberService{

    private MemberRepository memberRepository;

    //생성자
    public MemberService(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }

    //setter
    public void setMemberRepository(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }

}
```

생성자와 Setter를 통해 MemberRepository를 상속받아서 구현된 클래스의 인스턴스를 실행시점에 외부에서 주입하면 클라이언트인 MemberService는 직접 구현체를 선택하지 않아도 됨.

- MemberRepository 인터페이스에만 의존 -> DIP 위반 문제 해결
- 클라이언트에서 코드 수정 필요 없어짐 -> OCP 위반 문제 해결

인스턴스를 실행 시점에 외부에서 주입해주는 역할을 스프링의 DI 컨테이너가 함.



