### 의존관계 자동 주입

#### 의존관계 주입 방법
- 생성자 주입
  - 생성자 호출 시점에 딱 한번만 호출 보장
  - <b>불변, 필수</b> 의존관계에 사용
  - 생성자가 하나일 경우 `@Autowired` 생략 가능
- 수정자 주입(setter 주입)
  - <b>선택, 변경</b> 가능성 있는 의존관계에 사용
  - `@Autowired`로 주입할 대상이 없으면 오류 발생
- 필드 주입
  - 외부에서 변경 및 테스트 어려움
  - DI 프레임워크 필요
- 일반 메서드 주입
  - 한번에 여러 필드 주입 가능
  - 잘 사용하지 않음


#### 옵션 처리

스프링 빈이 존재하지 않으면 기본적으로 오류 발생

- `@Autowired(required=false)`: 자동 주입할 대상 없으면 수정자 메소드 호출 안함.
- `@Nullable`: 자동 주입할 대상 없으면 Null
- `@Optional`: 자동 주입할 대상 없으면 Optional.empty


#### 생성자 주입을 쓰는 이유

- 불변성
  - 의존 관계를 변경할 상황이 거의 없음.
  - 수정자 주입의 경우 set 메서드를 public으로 사용하므로 변경될 가능성 존재
  - 생성자 주입은 객체 생성시 한번만 호출되므로 변경될 가능성 없음
- 누락
  - 생성자 주입만 final 사용 가능
  - 주입하는 객체가 누락되면 컴파일 시점에 오류 발생

#### Lombok

- 생성자가 1개뿐이면 `@Autowired` 생략
- `@RequiredArgsConstructor`
  - final 붙은 필드를 모아서 생성자 자동 생성

#### 조회 빈이 2개 이상인 경우

- `@Autowired`은 타입으로 빈을 조회
  - 같은 타입이 2개 이상인 경우 오류 발생
- 해결 방안
  - `@Autowired`필드명: 타입 매칭을 시도하고 빈이 2개 이상이면 필드명으로 매칭
  - `@Qualifer`: 해당 어노테이션으로 등록된 이름을 통해 매칭
  - `@Primary`: 해당 어노테이션을 가진 빈이 우선권 가짐.
  - 우선순위: `@Qualifer` > `@Primary`
- 조회한 빈이 모두 필요한 경우
  - List, Map 타입의 생성자 활용

> `@Qualifier("mainDiscountPolicy")`
> - 이름이 문자열이므로 컴파일시 타입 체크 불가
> - 직접 어노테이션 생성하여 사용 가능

#### 자동, 수동 운영 기준

- 최근 자동을 선호하는 추세
- 수동 빈 등록 사용하는 시점
  - 광범위하게 영향을 미치는 기술 지원 로직의 경우
    - 유지보수를 위해 설정정보에 바로 나타나도록
  - 비즈니스 로직 중 다형성 활용이 많은 경우
    - 자동의 경우 패키지에 묶어놓거나 수동 빈 등록해야 가독성에 유리




