### JPA 소개

#### SQL 중심적인 개발의 문제점

- 개발 언어 : 객체 지향 언어(Java, Scala, ...)
- 데이터베이스 : 관계형 DB(Oracle, MySQL, ...)

##### 객체와 RDB의 패러다임 불일치
  - 객체 : 캡슐화가 목표
  - RDB: 데이터를 정규화하여 보관이 목표
  
##### 결국 객체를 SQL로 변환하여 RDB에 저장하는 작업이 필요


#### 객체와 RDB의 차이

- 상속
  - RDB는 상속 기능이 없음.
  - 상속받은 객체를 DB에 저장하려면 객체를 분해, 각 테이블에 대한 SQL을 만들어야 함.
- 연관관계
    - 객체: 참조 사용(get메서드 이용)
    - 테이블: 외래키 사용
    - 객체는 한방향으로만, 테이블은 양방향으로 참조 가능
- 객체 그래프 탐색
  - 객체는 참조를 통해 자유롭게 다른 객체 탐색 가능
  - SQL은 처음 실행하는 SQL에 따라 탐색 범위 정해짐.
  - 진정한 의미의 계층 분할이 어려움.
    - 엔티티 신뢰 문제 발생
    - 모든 객체를 미리 로딩할 순 없음.
- 비교
  - RDB에서 조회: 같은 id 값이라도 인스턴스 불일치
  - 자바 컬렉션에서 조회: 같은 id이면 인스턴스 일치


##### 위와 같은 패러다임 불일치 문제를 JPA가 해결

#### JPA

- Java Persistence API
- 자바 진영의 ORM 기술 표준(인터페이스들의 모음)
  - 객체는 객체대로, RDB는 RDB대로 설계
  - ORM이 중간에서 매핑
  
##### JPA 동작

![jpa_operation](https://user-images.githubusercontent.com/101541542/163103598-2692b2d8-877d-4cb0-8105-03a71d51d287.png)

- 객체를 마치 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장
  - JPA를 구현한 ORM 프레임워크가 존재(Hibernate, EclipseLink)
- ORM 프레임워크는 적절한 SQL을 생성하여 DB에 객체를 저장

#### JPA를 사용해야하는 이유

- 객체 중심 개발
- 생산성
  - 반복적인 SQL 작성을 JPA가 처리
- 유지보수
  - 필드 추가, 삭제 시 코드 변경을 JPA가 처리
- 패러다임 불일치 해결
- 성능 최적화 기능 제공
  - 1차 캐시와 동일성 보장
  - 트랜젝션 지원하는 쓰기 지연
  - 지연 로딩
- 데이터 접근 추상화와 벤더 독립성
  - 추상화된 데이터 접근 계층을 제공하여 어플리케이션이 특정 DB에 종속되지 않음.
- 표준
  - 다른 구현 기술로 변경 쉬움.
