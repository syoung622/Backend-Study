### 영속성 관리

#### 엔티티 매니저 팩토리와 엔티티 매니저


![entitymanagerfactory_entitymanager](https://user-images.githubusercontent.com/101541542/163342194-8e1eabfb-bc5d-48b5-9a4c-fb09ab48d269.png)

- 엔티티 매니저 팩토리는 하나만 만들어서 어플리케이션 전체에서 공유(DB가 하나인 경우)
- 엔티티 매니저 팩토리는 여러 스레드가 동시 접근 가능
- 엔티티 매니저는 스레드 간 공유 불가(동시성 문제 발생)

#### 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 생성할 때 같이 생성, 인티티 매니저를 통해서 영속성 컨텍스트에 접근, 관리
``` java
// 엔티티 매니저를 사용해서 member 엔티티를 영속성 컨텍스트에 저장 
em.persist(member);
```

#### 엔티티의 생명주기

- 비영속(new/transient): 영속성 컨텍스트와 관계없는 새로운 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(remove): 삭제된 상태

#### 영속성 컨텍스트 특징
-  1차 캐시
   -  1차 캐시에 호출한 엔티티가 존재하면 1차 캐시에서 엔티티 조회
   -  1차 캐시에 존재하지 않으면 DB에서 조회하여 1차 캐시에 엔티티 저장한 후 반환 
-  동일성 보장
   -  1차 캐시에 존재하는 동일한 엔티티 인스턴스를 반환
-  트랜잭션을 지원하는 쓰기 지연

   ![registerEntity](https://user-images.githubusercontent.com/101541542/163347965-0ef5f345-65ab-4baa-b18f-98c41b01062d.png)
   - persist() 하면서 생성한 SQL 코드를 쓰기 지연 SQL 저장소에 저장
   -  commit() 시점에 쓰기 지연 SQL 저장소에 있는 쿼리들을 수행하여 DB에 반영
   -  쿼리를 여러번 날리지 않는 최적화 가능
-  변경 감지
   -  commit() 시점에 스냅샷과의 비교를 통해서 엔티티 변경을 감지
   -  변경된 엔티티가 있으면 쿼리를 통해 쓰기 지연 SQL 저장소에 보냄.
   -  DB 트랜잭션을 commit()


#### 플러시

영속성 컨텍스트의 변경 사항을 DB에 반영

- 직접 호출
- 트랜잭션 커밋 시 플러시 자동 호출
- JPQL 쿼리 실행 시 플러시 자동 호출
  
> 참고: 플러시는 영속성 컨텍스트를 비우지 않음.

#### 준영속

- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능 사용 불가
  - 변경 감지, 1차 캐시 등


##### 준영속 상태 방법

- em.detach(entity)
  - 특정 엔티티만 준영속 상태로 변경
- em.clear()
  - 영속성 컨텍스트 초기화
- em.close()
  - 영속성 컨텍스트 종료